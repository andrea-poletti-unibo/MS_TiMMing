library(data.table)
library(tidyverse)




#============== load SMM&MGUS data and dataprep ================

#_______________ load SU2C new data and dataprep _______________
calls_suc <- fread("results/JB_paper/calls/clonalityCalls_broad_focal_SU2Cnew.txt")

purity_xlsx_suc <- readxl::read_xlsx("data/JB_Paper/DuttaAlberge_CleanClinicalRef_noMRN_29-06-23.xlsx")
purity_suc <- purity_xlsx_suc %>% select(sample = Reference_Pair, purity)

CI95_suc <- fread("results/JB_paper/calls/allCalls_CN_CI_broad_focal_SU2Cnew.txt")

# exclude MM from the analysis

anno <- readxl::read_xlsx("data/JB_Paper/final_Aug23/Annotations_SW.xlsx", sheet = 1)
anno <- anno %>% select(Reference_Pair, Disease_Status)

MMsample <- anno %>% filter(Disease_Status %in% c("MM","NDMM")) %>% pull(Reference_Pair)

MMsample %in% calls_suc$sample %>% table
# which true
calls_suc$sample[calls_suc$sample %in% MMsample]



anno$Reference_Pair %in% calls_suc$sample %>% table
# which false
calls_suc$sample[!calls_suc$sample %in% anno$Reference_Pair]

samples_anno_not_in_calls <- anno$Reference_Pair[!anno$Reference_Pair %in% calls_suc$sample]

samples_anno_not_in_calls %in% MMsample %>% table # all true

# remove MM samples from the SU2C cohort
calls_suc <- calls_suc %>% filter(!sample %in% MMsample) # n= 161 samples left
CI95_suc <- CI95_suc %>% filter(!ID %in% MMsample) # n= 161 samples left
purity_suc <- purity_suc %>% filter(!sample %in% MMsample) # n= 161 samples left



#____________ load BUS new data and dataprep _____________

#------ define samples to remove ------

# because of doublets with WGS
remove.samples <- paste0("SMM_", c("017", "040"), "_Tumor")
# beacuse of no myeloma / IGH mutation or cnv in actual genome data (only relies on FISH from clinic?)
remove.samples <- c(remove.samples, paste0("SMM_", str_pad(c(9, 29, 37, 38, 42), 3,side = "left", pad= "0"), "_Tumor"))
# because of non human contamination
remove.samples <- c(remove.samples, "SMM_074_Tumor")
# additional doublets discovered:
# 'SMM-076-Tumor' / SMM102 from British Cohort == MBp01
# 'SMM-081-Tumor' / SMM108 from British Cohort == MBp09
# 'SMM-093-Tumor' / SMM127 from British Cohort == MBp30
remove.samples <- c(remove.samples, paste0("SMM_", c("076", "081", "093"), "_Tumor"))
remove.samples <- str_replace(remove.samples, "SMM_", "SMM-") %>% str_replace("_Tumor", "_pair")


# calls bus
calls_bus <- fread("results/JB_paper/calls/clonalityCalls_broad_focal_BUSnew.txt")
calls_bus <- calls_bus %>% filter(!sample %in% remove.samples) # n= 164 samples left

# CI95 bus
CI95_bus <- fread("results/JB_paper/calls/allCalls_CN_CI_broad_focal_BUSnew.txt")
CI95_bus <- CI95_bus %>% filter(!ID %in% remove.samples) # n= 164 samples left

# purity bus
purity_TO_bus <- fread("data/Bustoros_WES/TO_RAPH_purity_table.txt")
purity_TN_bus <- fread("data/Bustoros_WES/TN_RAPH_purity_table.txt")
purity_bus <- rbind(purity_TO_bus, purity_TN_bus) %>% select(sample, purity)
purity_bus <- purity_bus %>% filter(sample %in% calls_bus$sample) # n= 164 samples left

purity_bus$purity[is.na(purity_bus$purity)] <- 1 # set NA to 1 (generated by all normals of RAPH)


# ____________ merge data ____________

names(calls_bus) %in% names(calls_suc) %>% table()
# which false
names(calls_bus)[!names(calls_bus) %in% names(calls_suc)]

# remove the two columns  "amp_chr_21p" "del_chr_21p"
calls_bus <- calls_bus %>% select(-"amp_chr_21p", -"del_chr_21p")
# remove the chr 21 column also in bus CI
CI95_bus <- CI95_bus %>% select(-"chr_21p")


calls_0 <- rbind(calls_suc, calls_bus)
CI95_0 <- rbind(CI95_suc, CI95_bus)
purity_0 <- rbind(purity_suc, purity_bus)


allsamples <- calls_0$sample

#===================== SPLIT DATA in half =====================



half <- round(length(allsamples) / 2)

halfsamples <- sample(allsamples, half, replace = FALSE)

calls_0a <- calls_0 %>% filter(sample %in% halfsamples)
CI95_0a <- CI95_0 %>% filter(ID %in% halfsamples)
purity_0a <- purity_0 %>% filter(sample %in% halfsamples)

calls_0b <- calls_0 %>% filter(!sample %in% halfsamples)
CI95_0b <- CI95_0 %>% filter(!ID %in% halfsamples)
purity_0b <- purity_0 %>% filter(!sample %in% halfsamples)




######################### TIMMING MODEL SMM-a #########################
######################### 20 bootstraps #########################

outdir <- "workfiles/validation_tests/T2_split_SMM/split_SMM-a/"
dir.create(outdir, showWarnings = FALSE, recursive = TRUE)


# order step VERY IMPORTANT fot boot

calls_ORIG <- calls_0a %>% arrange(sample)
CI95_ORIG <- CI95_0a %>% arrange(ID)
purity_ORIG <- purity_0a %>% arrange(sample)


# check
(calls_ORIG$sample == purity_ORIG$sample) %>% table()
(CI95_ORIG$ID == purity_ORIG$sample) %>% table()
(CI95_ORIG$ID == calls_ORIG$sample) %>% table()


b <- 1

boot_data <- data.frame()


library(parallel)
library(doParallel)
library(foreach)
library(doSNOW)

N_cores <- parallel::detectCores() - 2

cl <- makeCluster(N_cores)
registerDoSNOW(cl)


for (b in 1:20) {
    
    NUM <- nrow(calls_ORIG)

    # sample with replacement
    set.seed(123 + b)
    boot <- sample(1:NUM, NUM, replace = TRUE)

    boot %>%
        table() %>%
        sort()

    boot_data <- rbind(boot_data, data.frame(idx = boot, boot_n = b, sample=calls_ORIG[boot, ]$sample))

    calls_b <- calls_ORIG[boot, ]
    CI95_b <- CI95_ORIG[boot, ]
    purity_b <- purity_ORIG[boot, ]

    # assigb new names in boot mode
    calls_b$sample <- paste0("SMM_", str_pad(1:NUM, 3, side = "left", pad = "0"), "_Boot_", b)
    CI95_b$ID <- paste0("SMM_", str_pad(1:NUM, 3, side = "left", pad = "0"), "_Boot_", b)
    purity_b$sample <- paste0("SMM_", str_pad(1:NUM, 3, side = "left", pad = "0"), "_Boot_", b)

    # save bootstraps
    calls <- calls_b
    CI95 <- CI95_b
    purity <- purity_b

    # ================ start BTmodel dataprep ================

    dfCI <- apply(CI95, c(1, 2), function(x) str_remove(x, ".*\\|"))

    dfCI_m <- dfCI %>%
        as.data.frame() %>%
        reshape2::melt(id.vars = "ID") %>%
        setNames(c("sample", "chrarm", "CI95"))


    # melt the data => 1 row per event observation
    melt <- melt(calls, id.vars = "sample")

    # add purity calls
    melt <- left_join(melt, purity %>% dplyr::select(sample, purity), by = c("sample"))

    # compute call thresholds based on purity levels
    melt$thresh <- 0.05 / melt$purity

    melt$call <- ifelse(melt$value > melt$thresh, 1, 0)


    # add 95% Confidence Intervals
    melt$chrarm <- melt$variable %>% str_remove("amp_|del_")

    melt <- left_join(melt, dfCI_m, by = c("sample", "chrarm"))

    melt$CI95 <- as.numeric(melt$CI95)


    # ====================== generate HD call for each sample ====================

    melt$HD_chr <- ifelse(melt$variable %>% str_detect("amp_chr_[3579]|amp_chr_1[159]|amp_chr_21"), "yes", "no")

    # melt %>% group_by(variable) %>% summarise(A=unique(HD_chr)) %>% View

    cohort <- unique(melt$sample)

    melt_HD <- data.frame()

    pt <- cohort[1]

    # CALL HyperDiploidy CLONALITY (median value if n HD arms >= 3)
    for (pt in cohort) {
        # message(which(pt==cohort))

        p <- melt %>% filter(sample == pt)
        p_HD <- p %>% filter(HD_chr == "yes" & call == 1)

        if (nrow(p_HD) > 3) {
            HD_value <- median(p_HD$value)
            HD_CI <- median(p_HD$CI95)

            # modify value on arms to avoid redundancy
            p$value[p$HD_chr == "yes" & p$call == 1] <- -999
            p$call[p$HD_chr == "yes" & p$call == 1] <- -999
        } else {
            HD_value <- 0
        }

        HD_player <- data.frame(
            sample = pt,
            variable = "HyperDiploidy",
            value = HD_value,
            purity = p$purity %>% unique(),
            thresh = p$thresh %>% unique(),
            call = ifelse(HD_value > 0, 1, 0),
            chrarm = NA,
            CI95 = HD_CI,
            HD_chr = NA
        )

        p <- rbind(p, HD_player)

        melt_HD <- rbind(melt_HD, p)
    }

    # ================= create the players ====================

    players <- c(melt_HD$variable %>% unique() %>% as.character())

    # ================= create the matches =========================

    matches <- t(combn(players, 2))

    matches.df <- data.frame(
        player1 = matches[, 1],
        player2 = matches[, 2]
    )

    matches.df$player1 <- as.character(matches.df$player1)
    matches.df$player2 <- as.character(matches.df$player2)
    matches.df %>% str()

    matches.df$win1 <- 0
    matches.df$win2 <- 0

    # delete nosense matches (same chrarm - amp vs del and mut)
    same.check <- function(var1, var2) {
        v1 <- var1 %>% str_extract("[0-9]+[pq]|Hyper|^mut.*")
        v2 <- var2 %>% str_extract("[0-9]+[pq]|Hyper|^mut.*")
        same <- v1 != v2
        same %>% table()
        same
    }


    senseIDX <- same.check(matches.df$player1, matches.df$player2)
    senseIDX %>% table()

    matches.dfREV <- matches.df[!senseIDX, ]

    matches.df <- matches.df[senseIDX, ]

    matches.df$matchID <- 1:nrow(matches.df)



    ##################### statistical Clonal Difference (ClonDiff) method ##################

    # load TestClonality function
    source("scripts/my_functions/TestClonality_Confidence_Interval_statistical_difference.R")

    cohort <- unique(melt_HD$sample)


    # ================ PARALLEL LOOP over samples > tournaments ====================

    iterations <- length(cohort)

    # iterations <- 3
    # progress bar ------------------------------------------------------------
    library(progress)
    pb <- progress_bar$new(
        format = "letter = :letter [:bar] :elapsed | eta: :eta",
        total = iterations, # 100
        width = 60
    )
    progress_letter <- rep(LETTERS[1:10], 10) # token reported in progress bar

    # allowing progress bar to be used in foreach -----------------------------
    progress <- function(n) {
        pb$tick(tokens = list(letter = progress_letter[n]))
    }

    opts <- list(progress = progress)


    i <- 1



    parRes <- foreach(
        i = 1:iterations,
        .packages = "tidyverse",
        .options.snow = opts
    ) %dopar% {
        pt <- cohort[i]
        tournament.pt <- melt_HD %>% filter(sample == pt)
        matches_res <- matches.df

        matches_res$performed <- 0
        matches_res$sample <- pt

        m <- 1
        for (m in 1:nrow(matches_res)) {
            if (m %% 500 == 0) message(m)

            mtc <- matches_res[m, 1:2]
            pl1 <- mtc$player1
            pl2 <- mtc$player2

            pl1_stats <- tournament.pt %>% filter(variable == pl1)
            pl2_stats <- tournament.pt %>% filter(variable == pl2)

            # _____________ if both event are present: perform a match ________________

            if (pl1_stats$call == 1 & pl2_stats$call == 1) {
                # check if distributions are significantly different based on value and CI95% (method 1 - TestClonality)
                testclon_res <- TestClonality(
                    pl1_score = pl1_stats$value,
                    pl2_score = pl2_stats$value,
                    CI_1 = pl1_stats$CI95,
                    CI_2 = pl2_stats$CI95,
                    outplot = F
                )

                # do actual match
                if (testclon_res$test_result == "significative p<0.05") {
                    # declare winner
                    winner <- (which.max(c(pl1_stats$value, pl2_stats$value)))

                    # declare points = proportional to the clonality difference (ClonDiff method)
                    points <- round((abs(pl1_stats$value - pl2_stats$value) * 100) / 20)

                    # assign points to winner and record
                    colnames(matches_res)
                    if (winner == 1 & points > 0) {
                        matches_res[m, "win1"] <- matches_res[m, "win1"] + points
                        matches_res[m, "performed"] <- 1
                    } else if (winner == 2 & points > 0) {
                        matches_res[m, "win2"] <- matches_res[m, "win2"] + points
                        matches_res[m, "performed"] <- 1
                    }
                }
            }
        }

        matches_res
    }

    # ___aggregate all tables scores____

    all <- Reduce(rbind, parRes)

    expscorestab <- all %>%
        group_by(matchID) %>%
        summarise(
            player1 = unique(player1),
            player2 = unique(player2),
            win1 = sum(win1),
            win2 = sum(win2),
            total_matches_performed = sum(performed)
        )

    # save aggregated table with points
    write_tsv(expscorestab, paste0(outdir,"/split_SMM-a_BOOT_",b,"_matches_results_ClonDiffPoints.txt"))
}

stopCluster(cl)

write_tsv(boot_data, paste0(outdir, "/split_SMM-a_BOOT-data.txt")) 








######################### TIMMING MODEL SMM-b #########################
######################### 20 bootstraps #########################

outdir <- "workfiles/validation_tests/T2_split_SMM/split_SMM-b/"
dir.create(outdir, showWarnings = FALSE, recursive = TRUE)


# order step VERY IMPORTANT fot boot

calls_ORIG <- calls_0b %>% arrange(sample)
CI95_ORIG <- CI95_0b %>% arrange(ID)
purity_ORIG <- purity_0b %>% arrange(sample)


# check
(calls_ORIG$sample == purity_ORIG$sample) %>% table()
(CI95_ORIG$ID == purity_ORIG$sample) %>% table()
(CI95_ORIG$ID == calls_ORIG$sample) %>% table()


b <- 1

boot_data <- data.frame()


library(parallel)
library(doParallel)
library(foreach)
library(doSNOW)

N_cores <- parallel::detectCores() - 2

cl <- makeCluster(N_cores)
registerDoSNOW(cl)


for (b in 1:20) {
    
    NUM <- nrow(calls_ORIG)

    # sample with replacement
    set.seed(123 + b)
    boot <- sample(1:NUM, NUM, replace = TRUE)

    boot %>%
        table() %>%
        sort()

    boot_data <- rbind(boot_data, data.frame(idx = boot, boot_n = b, sample=calls_ORIG[boot, ]$sample))

    calls_b <- calls_ORIG[boot, ]
    CI95_b <- CI95_ORIG[boot, ]
    purity_b <- purity_ORIG[boot, ]

    # assigb new names in boot mode
    calls_b$sample <- paste0("SMM_", str_pad(1:NUM, 3, side = "left", pad = "0"), "_Boot_", b)
    CI95_b$ID <- paste0("SMM_", str_pad(1:NUM, 3, side = "left", pad = "0"), "_Boot_", b)
    purity_b$sample <- paste0("SMM_", str_pad(1:NUM, 3, side = "left", pad = "0"), "_Boot_", b)

    # save bootstraps
    calls <- calls_b
    CI95 <- CI95_b
    purity <- purity_b

    # ================ start BTmodel dataprep ================

    dfCI <- apply(CI95, c(1, 2), function(x) str_remove(x, ".*\\|"))

    dfCI_m <- dfCI %>%
        as.data.frame() %>%
        reshape2::melt(id.vars = "ID") %>%
        setNames(c("sample", "chrarm", "CI95"))


    # melt the data => 1 row per event observation
    melt <- melt(calls, id.vars = "sample")

    # add purity calls
    melt <- left_join(melt, purity %>% dplyr::select(sample, purity), by = c("sample"))

    # compute call thresholds based on purity levels
    melt$thresh <- 0.05 / melt$purity

    melt$call <- ifelse(melt$value > melt$thresh, 1, 0)


    # add 95% Confidence Intervals
    melt$chrarm <- melt$variable %>% str_remove("amp_|del_")

    melt <- left_join(melt, dfCI_m, by = c("sample", "chrarm"))

    melt$CI95 <- as.numeric(melt$CI95)


    # ====================== generate HD call for each sample ====================

    melt$HD_chr <- ifelse(melt$variable %>% str_detect("amp_chr_[3579]|amp_chr_1[159]|amp_chr_21"), "yes", "no")

    # melt %>% group_by(variable) %>% summarise(A=unique(HD_chr)) %>% View

    cohort <- unique(melt$sample)

    melt_HD <- data.frame()

    pt <- cohort[1]

    # CALL HyperDiploidy CLONALITY (median value if n HD arms >= 3)
    for (pt in cohort) {
        # message(which(pt==cohort))

        p <- melt %>% filter(sample == pt)
        p_HD <- p %>% filter(HD_chr == "yes" & call == 1)

        if (nrow(p_HD) > 3) {
            HD_value <- median(p_HD$value)
            HD_CI <- median(p_HD$CI95)

            # modify value on arms to avoid redundancy
            p$value[p$HD_chr == "yes" & p$call == 1] <- -999
            p$call[p$HD_chr == "yes" & p$call == 1] <- -999
        } else {
            HD_value <- 0
        }

        HD_player <- data.frame(
            sample = pt,
            variable = "HyperDiploidy",
            value = HD_value,
            purity = p$purity %>% unique(),
            thresh = p$thresh %>% unique(),
            call = ifelse(HD_value > 0, 1, 0),
            chrarm = NA,
            CI95 = HD_CI,
            HD_chr = NA
        )

        p <- rbind(p, HD_player)

        melt_HD <- rbind(melt_HD, p)
    }

    # ================= create the players ====================

    players <- c(melt_HD$variable %>% unique() %>% as.character())

    # ================= create the matches =========================

    matches <- t(combn(players, 2))

    matches.df <- data.frame(
        player1 = matches[, 1],
        player2 = matches[, 2]
    )

    matches.df$player1 <- as.character(matches.df$player1)
    matches.df$player2 <- as.character(matches.df$player2)
    matches.df %>% str()

    matches.df$win1 <- 0
    matches.df$win2 <- 0

    # delete nosense matches (same chrarm - amp vs del and mut)
    same.check <- function(var1, var2) {
        v1 <- var1 %>% str_extract("[0-9]+[pq]|Hyper|^mut.*")
        v2 <- var2 %>% str_extract("[0-9]+[pq]|Hyper|^mut.*")
        same <- v1 != v2
        same %>% table()
        same
    }


    senseIDX <- same.check(matches.df$player1, matches.df$player2)
    senseIDX %>% table()

    matches.dfREV <- matches.df[!senseIDX, ]

    matches.df <- matches.df[senseIDX, ]

    matches.df$matchID <- 1:nrow(matches.df)



    ##################### statistical Clonal Difference (ClonDiff) method ##################

    # load TestClonality function
    source("scripts/my_functions/TestClonality_Confidence_Interval_statistical_difference.R")

    cohort <- unique(melt_HD$sample)


    # ================ PARALLEL LOOP over samples > tournaments ====================

    iterations <- length(cohort)

    # iterations <- 3
    # progress bar ------------------------------------------------------------
    library(progress)
    pb <- progress_bar$new(
        format = "letter = :letter [:bar] :elapsed | eta: :eta",
        total = iterations, # 100
        width = 60
    )
    progress_letter <- rep(LETTERS[1:10], 10) # token reported in progress bar

    # allowing progress bar to be used in foreach -----------------------------
    progress <- function(n) {
        pb$tick(tokens = list(letter = progress_letter[n]))
    }

    opts <- list(progress = progress)


    i <- 1



    parRes <- foreach(
        i = 1:iterations,
        .packages = "tidyverse",
        .options.snow = opts
    ) %dopar% {
        pt <- cohort[i]
        tournament.pt <- melt_HD %>% filter(sample == pt)
        matches_res <- matches.df

        matches_res$performed <- 0
        matches_res$sample <- pt

        m <- 1
        for (m in 1:nrow(matches_res)) {
            if (m %% 500 == 0) message(m)

            mtc <- matches_res[m, 1:2]
            pl1 <- mtc$player1
            pl2 <- mtc$player2

            pl1_stats <- tournament.pt %>% filter(variable == pl1)
            pl2_stats <- tournament.pt %>% filter(variable == pl2)

            # _____________ if both event are present: perform a match ________________

            if (pl1_stats$call == 1 & pl2_stats$call == 1) {
                # check if distributions are significantly different based on value and CI95% (method 1 - TestClonality)
                testclon_res <- TestClonality(
                    pl1_score = pl1_stats$value,
                    pl2_score = pl2_stats$value,
                    CI_1 = pl1_stats$CI95,
                    CI_2 = pl2_stats$CI95,
                    outplot = F
                )

                # do actual match
                if (testclon_res$test_result == "significative p<0.05") {
                    # declare winner
                    winner <- (which.max(c(pl1_stats$value, pl2_stats$value)))

                    # declare points = proportional to the clonality difference (ClonDiff method)
                    points <- round((abs(pl1_stats$value - pl2_stats$value) * 100) / 20)

                    # assign points to winner and record
                    colnames(matches_res)
                    if (winner == 1 & points > 0) {
                        matches_res[m, "win1"] <- matches_res[m, "win1"] + points
                        matches_res[m, "performed"] <- 1
                    } else if (winner == 2 & points > 0) {
                        matches_res[m, "win2"] <- matches_res[m, "win2"] + points
                        matches_res[m, "performed"] <- 1
                    }
                }
            }
        }

        matches_res
    }

    # ___aggregate all tables scores____

    all <- Reduce(rbind, parRes)

    expscorestab <- all %>%
        group_by(matchID) %>%
        summarise(
            player1 = unique(player1),
            player2 = unique(player2),
            win1 = sum(win1),
            win2 = sum(win2),
            total_matches_performed = sum(performed)
        )

    # save aggregated table with points
    write_tsv(expscorestab, paste0(outdir,"/split_SMM-b_BOOT_",b,"_matches_results_ClonDiffPoints.txt"))
}

stopCluster(cl)

write_tsv(boot_data, paste0(outdir, "/split_SMM-b_BOOT-data.txt")) 